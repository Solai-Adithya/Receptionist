{% extends 'base.html' %}
{% block main_content %}
{% block addl_css %}
<script type="text/javascript" src="http://code.jquery.com/jquery-latest.min.js"></script>
<link rel="stylesheet" type="text/css" href="{{ url_for('static',filename='manage.css') }}">
<script src="react-test-file.js"></script>
{% endblock %}

<!-- Create a space with interview controls. 
1) option to notify next person in queue once you invite one person to the meet - default on.
2) option to expose meet link only when the person is invited or notified - default on.
3) Show participants their respective queue positions based on the number of invites you have sent - default on. 
-->

<div class="table-responsive">
  <h3>Invited Participants</h3>
  <ol class="list-group participants invited">
    <!-- List of invited participants -->
    <!-- Here the invite button should become notify and the interviewer should be able to notify the person again if needed -->
    {% for participant in invitedParticipants %}
    {% set user = participant["user"] %}
    <li class="list-group-item d-flex justify-content-between align-items-start">
      <div class="ms-2 me-auto name-container">
        <div class="profile-pic">
          <span class="imgHelper"></span>
          <img class="rounded-circle" src="{{user['profile_pic']}}" width="55" />
        </div>
        <div class="name">{{user['name']}}</div>
        <div class="email">{{user['email']}}</div>
      </div>
      <div class="btn-group status">
        <button type="button" class="btn btn-danger notify-button" onclick="notify(`{{user['email']}}`, `{{roomID}}`)"
          aria-expanded="false">
          Notify again
        </button>
        <!-- Make a separate group of participants who have already been invited and hence have null queue-position -->
        <!-- Later give an option to export all data including sno, email, name, score and review in csv format -->
        <!-- Finally make a small dropdown button to postpone or cancel the interview. -->
      </div>
    </li>
    {% endfor %}
  </ol>
  <hr>
  <h3>Participants in Queue</h3>
  <ol class="list-group participants not-invited">
    <!-- List of participants not yet invited -->
    {% for participant in uninvitedParticipants %}
    {% set user = participant["user"] %}
    <li class="list-group-item d-flex justify-content-between align-items-start">
      <div class="queue-position">{{participant["queuePosition"]}}</div>
      <div class="ms-2 me-auto name-container">
        <div class="profile-pic">
          <span class="imgHelper"></span>
          <img class="rounded-circle" src="{{user['profile_pic']}}" width="55" />
        </div>
        <div class="name">{{user['name']}}</div>
        <div class="email">{{user['email']}}</div>
      </div>
      <div class="btn-group status">
        <button type="button" class="btn btn-danger invite-button" onclick="invite(`{{user['email']}}`, `{{roomID}}`)"
          aria-expanded="false">
          Invite
        </button>
        <!-- Make a separate group of participants who have already been invited and hence have null queue-position -->
        <!-- Later give an option to export all data including sno, email, name, score and review in csv format -->
        <!-- Finally make a small dropdown button to postpone or cancel the interview. -->
      </div>
    </li>
    {% endfor %}
  </ol>
</div>
<script>
  async function invite(email, roomID) {
    var not_invited = document.getElementById("not-invited");
    var invited = document.getElementById("invited");
    console.log("Starting")
    const rawResponse = await fetch('/invite', {
      method: 'POST',
      dataType: 'json',
      headers: {
        'Accept': 'application/json',
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({ "email": email, "roomID": roomID })
    });
  }

  async function notify(email, roomID) {
    const rawResponse = await fetch('/notify', {
      method: 'POST',
      dataType: 'json',
      headers: {
        'Accept': 'application/json',
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({ "email": email, "roomID": roomID })
    });
  }

  // BOILERPLATE
  function notifyMe(user, message) {
    // Let's check if the browser supports notifications
    if (!("Notification" in window)) {
      alert("This browser does not support desktop notification");
    }
    // Let's check if the user is okay to get some notification
    else if (Notification.permission === "granted") {
      // If it's okay let's create a notification
      var options = {
        body: message,
      };
      var notification = new Notification(user + " Posted a comment", options);
    }
    // Otherwise, we need to ask the user for permission
    // Note, Chrome does not implement the permission static property
    // So we have to check for NOT 'denied' instead of 'default'
    else if (Notification.permission !== 'denied') {
      Notification.requestPermission(function (permission) {
        // Whatever the user answers, we make sure we store the information
        if (!('permission' in Notification)) {
          Notification.permission = permission;
        }
        // If the user is okay, let's create a notification
        if (permission === "granted") {
          var options = {
            body: message,
            dir: "ltr"
          };
          var notification = new Notification(user + " Posted a comment", options);
        }
      });
    }
  }

		  // At last, if the user already denied any notification, and you
		  // want to be respectful there is no need to bother them any more.
</script>
{% endblock %}